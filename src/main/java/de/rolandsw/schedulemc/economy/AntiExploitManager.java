package de.rolandsw.schedulemc.economy;

import com.mojang.logging.LogUtils;
import de.rolandsw.schedulemc.config.ModConfigHandler;
import org.slf4j.Logger;

import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Verhindert wirtschaftliche Exploits und Missbrauch.
 *
 * Tracking:
 * - Tägliche Verkaufsvolumen pro Spieler
 * - Mass-Selling Detection (zu schnelles Verkaufen großer Mengen)
 * - Preis-Penalties bei Exploit-Verdacht
 */
public class AntiExploitManager {

    private static final Logger LOGGER = LogUtils.getLogger();
    private static volatile AntiExploitManager instance;

    /** Tägliche Verkaufsvolumen pro Spieler */
    private final ConcurrentHashMap<UUID, Double> dailySellVolume = new ConcurrentHashMap<>();

    /** Letzte Verkaufszeit pro Spieler (für Cooldown-Check) */
    private final ConcurrentHashMap<UUID, Long> lastSellTime = new ConcurrentHashMap<>();

    /** Verkaufte Menge im aktuellen Cooldown-Fenster pro Spieler */
    private final ConcurrentHashMap<UUID, Integer> cooldownSellCount = new ConcurrentHashMap<>();

    /** Warnstufe pro Spieler (0-3) */
    private final ConcurrentHashMap<UUID, Integer> warningLevel = new ConcurrentHashMap<>();

    private AntiExploitManager() {}

    public static AntiExploitManager getInstance() {
        AntiExploitManager localRef = instance;
        if (localRef == null) {
            synchronized (AntiExploitManager.class) {
                localRef = instance;
                if (localRef == null) {
                    instance = localRef = new AntiExploitManager();
                }
            }
        }
        return localRef;
    }

    /**
     * Prüft ob ein Verkauf erlaubt ist und gibt den Preis-Multiplikator zurück.
     *
     * @param playerUUID Spieler-UUID
     * @param amount     Verkaufsmenge
     * @param revenue    Erwarteter Umsatz
     * @return Preis-Multiplikator (1.0 = normal, <1.0 = Penalty)
     */
    public double checkAndGetMultiplier(UUID playerUUID, int amount, double revenue) {
        double dailyLimit = ModConfigHandler.COMMON.ANTI_EXPLOIT_DAILY_SELL_LIMIT.get();
        int massSellThreshold = ModConfigHandler.COMMON.ANTI_EXPLOIT_MASS_SELL_THRESHOLD.get();
        int massSellCooldownMs = ModConfigHandler.COMMON.ANTI_EXPLOIT_MASS_SELL_COOLDOWN_SECONDS.get() * 1000;
        double massSellPenalty = ModConfigHandler.COMMON.ANTI_EXPLOIT_MASS_SELL_PENALTY.get();

        double currentDailyVolume = dailySellVolume.getOrDefault(playerUUID, 0.0);
        double multiplier = 1.0;

        // 1. Tägliches Limit prüfen
        if (currentDailyVolume + revenue > dailyLimit) {
            double overLimit = (currentDailyVolume + revenue) - dailyLimit;
            double overPercent = overLimit / dailyLimit;
            // Progressiver Penalty: Je mehr über dem Limit, desto stärker
            multiplier *= Math.max(0.3, 1.0 - overPercent * 0.5);
            LOGGER.info("Daily sell limit approached for {}: {:.2f}/{:.2f}€, penalty: {:.2f}x",
                    playerUUID, currentDailyVolume + revenue, dailyLimit, multiplier);
        }

        // 2. Mass-Selling Detection
        if (amount >= massSellThreshold) {
            long now = System.currentTimeMillis();
            long lastTime = lastSellTime.getOrDefault(playerUUID, 0L);
            int cooldownCount = cooldownSellCount.getOrDefault(playerUUID, 0);

            if (now - lastTime < massSellCooldownMs) {
                // Verkauf innerhalb des Cooldowns
                cooldownSellCount.put(playerUUID, cooldownCount + amount);
                multiplier *= massSellPenalty;

                // Warnstufe erhöhen
                int warns = warningLevel.merge(playerUUID, 1, Integer::sum);
                if (warns >= 3) {
                    multiplier *= 0.5; // Starke Penalty bei wiederholtem Mass-Selling
                    LOGGER.warn("Repeated mass-selling detected for {}: level {}", playerUUID, warns);
                }
            } else {
                // Neues Cooldown-Fenster
                cooldownSellCount.put(playerUUID, amount);
            }
            lastSellTime.put(playerUUID, now);
        }

        // Tracking aktualisieren
        dailySellVolume.merge(playerUUID, revenue * multiplier, Double::sum);

        return multiplier;
    }

    /**
     * Prüft ob ein Spieler das tägliche Limit erreicht hat.
     */
    public boolean isDailyLimitReached(UUID playerUUID) {
        double dailyLimit = ModConfigHandler.COMMON.ANTI_EXPLOIT_DAILY_SELL_LIMIT.get();
        return dailySellVolume.getOrDefault(playerUUID, 0.0) >= dailyLimit;
    }

    /**
     * Gibt den aktuellen täglichen Umsatz eines Spielers zurück.
     */
    public double getDailySellVolume(UUID playerUUID) {
        return dailySellVolume.getOrDefault(playerUUID, 0.0);
    }

    /**
     * Gibt die Warnstufe eines Spielers zurück.
     */
    public int getWarningLevel(UUID playerUUID) {
        return warningLevel.getOrDefault(playerUUID, 0);
    }

    /**
     * Wird täglich aufgerufen um Zähler zurückzusetzen.
     */
    public void onNewDay() {
        dailySellVolume.clear();
        cooldownSellCount.clear();
        // Warnstufen werden nicht zurückgesetzt - die bleiben persistent
        LOGGER.info("Anti-exploit daily counters reset");
    }

    /**
     * Setzt die Warnstufe eines Spielers zurück (Admin-Funktion).
     */
    public void resetWarnings(UUID playerUUID) {
        warningLevel.remove(playerUUID);
    }

    /**
     * Setzt alle Warnstufen zurück (Admin-Funktion).
     */
    public void resetAllWarnings() {
        warningLevel.clear();
    }
}
